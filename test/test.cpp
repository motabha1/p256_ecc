#include "../src/utility.h"
#include "../src/field_arithmetic.h"
#include "test.h"
#include "../src/ec_arithmetic.h"

#include <iostream>
using namespace std;

/**
 * @brief Tests whether field addition is working correctly or not
 * Inputs can be given from the main function
 * @param a 
 * @param b 
 * @param c 
 */
void test_add(int_256 a, int_256 b, int_256 c)
{
	show_number(a, "a = ");
	show_number(b, "b = ");
	int_256 d = int_add(a, b);
	show_number(d, "d = ");
	show_number(c, "c = ");
	if (is_equal(c, d))
	{
		cout << "ADDITION TEST SUCCESS!\n";
	}
	else
	{
		cout << "ADDITION TEST FAILED!\n";
	}
}

/**
 * @brief Checks whether field addition is working correctly
 * 
 * @param a 
 * @param b 
 * @param c 
 */
void test_sub(int_256 a, int_256 b, int_256 c)
{
	int_256 d = sub(a, b);
	if (is_equal(c, d))
	{
		cout << "SUBTRACTION TEST SUCCESS!\n";
	}
	else
	{
		cout << "SUBTRACTION TEST FAILED!\n";
	}
}

/**
 * @brief Checks whether field multiplication is working correctly
 * 
 * @param a 
 * @param b 
 * @param c 
 */
void test_mul(int_256 a, int_256 b, int_256 c)
{
	int_256 d = mul(a, b);
	if (is_equal(c, d))
	{
		cout << "MULTIPLICATION TEST SUCCESS!\n";
	}
	else
	{
		cout << "MULTIPLICATION TEST FAILED!\n";
	}
}

/**
 * @brief By fermat's little theorem, a^(p-1) = 1 (mod p)
 * Thus, x = a^(p-2) is a solution to a.x = 1 (mod p)
 * So a^(-1) = a^(p-2) mod p 
 * We check the inverse function here by multiplying these two and check whether they equate to ONE
 * @param a 
 */
void test_inverse(int_256 a)
{
	int_256 aa = exp(a, P256_2);
	if (is_equal(mul(aa, a), ONE))
	{
		cout << "INVERSE TEST SUCCESS!\n";
	}
	else
	{
		int_256 gg = mul(aa, a);
		for (int i = 0; i < gg.size; i++)
			cout << gg.x[i] << " ";
		cout << "INVERSE TEST FAILED!\n";
	}
}

/**
 * @brief This function checks the key exchange which in turn checks the validity 
 * of elliptic curve arithmetic. The points on the curve were randomly generated by using SageMath
 * The generator elements for the prime P256 are given in the utility file
 * Using this we check whether the two points Alice and Bob obtain after key exchange are equal
 * 
 * @param alice_priv 
 * @param bob_priv 
 */
void test_field(int_256 alice_priv, int_256 bob_priv)
{
	curve_pt G;
	G.X = Gx; G.Y = Gy;

	curve_pt alice_pub = scalar_mul(G, alice_priv);
	curve_pt bob_pub = scalar_mul(G, bob_priv);

	curve_pt aaa = scalar_mul(alice_pub, bob_priv);
	curve_pt bbb = scalar_mul(bob_pub, alice_priv);

	if(pt_equal(aaa, bbb)){
		cout << "KEYS ARE SUCCESSFULLY EXCHANGED!!\n";
	}
	else{
		cout << "START DEBUGGING THIS CODE ASAP!\n";
	}
}
